# クラス設計

**クラスを設計する上で重要なのはクラス単体で正常に動作し、クラスを利用する者はクラスの実装を気にせずに利用できることである。**

例えば、そのクラスを利用する際に、初期値を設定しなければいけなかったり値のバリデーションを実装しないといけなかったりする時点でそれはクラスとして不十分である。また、バグを引き起こしそうな実装があるのであればガード節などを使ってバグを起こさないように、クラス内で対処しないといけない。そのようなクラスを設計するための方法についてまとめる。

## コンストラクタで初期化する

コンストラクタを実装しないと生焼けオブジェクトが生成されてしまう。生焼けオブジェクトとは初期化されていないオブジェクトのことである。具体例を見る。

```java
public class ContractAmount {
    public int amountIncludingTax;
    public BigDecimal salesTaxRate;
    //コンストラクタ
    public ContractAmount(int amountIncludingTax, BigDecimal salesTaxRate) {
        this.amountIncludingTax = amountIncludingTax;
        //this.salesTaxRate = salesTaxRate;
    }
}
```

上のような処理があったとする。salesTaxRateは初期化されていない。

```java
ContractAmount amount = new ContractAmount();
System.out.println(amount.salesTaxRate.toString());
```

この状態のクラスをインスタンス化すると上のようになる。この時、salesTaxRateはコンストラクで初期されないようになっているので２行目でぬるぽが発生する。これを改善するためにコンストラクタ内で初期化するようにする。

```java
public class ContractAmount {
    public int amountIncludingTax;
    public BigDecimal salesTaxRate;
    //コンストラクタ
    public ContractAmount(int amountIncludingTax, BigDecimal salesTaxRate) {
        this.amountIncludingTax = amountIncludingTax;
        this.salesTaxRate = salesTaxRate;
    }
}
```

上のようにコンストラクタで初期化すれば、利用者はこのクラスを使用する際に必ず初期化する必要があるので、ぬるぽが起きない。コンストラクタで初期化を行なっておけば、もしクラスを利用時に初期化を忘れるとコンパイルエラーが起きるのでクラスの利用者は初期化を強制される。

```java
ContractAmount amount = new ContractAmount(10000, BigDecimal.valueOf(0.08));
System.out.println(amount.amountIncludingTax); // 10000
System.out.println(amount.salesTaxRate); // 0.08
```



## ガード節を設定する

引数を与えるときにはガード節を設置して不正な値がクラス内に入り込むことを防ぐ。

```java
Class Money{
 int amount;//金額
 Currency currency;//通過
 if（amount<0）{
 throw new IllegaryArgumenetException("金額には０以上を設定してください");)
 }
 if（currency==null）{
 throw new IllegaryArgumenetException("通過単位を指定してください");
 }
 Money(int amount,Currency currency){
  this.amount=amount;
  this.currency=currency;
  } 
}
```

上のように設定することで、金額がマイナス、通貨がnullになるようなパターンを取り除くことができる。

## 計算ロジックをデータクラスに記述する

一般的にデータクラスを定義するときにはデータと計算ロジックは同じクラスに記述し、高凝集にした方がいい。こうすることで別ファイルに重複した処理が増えたり、修正漏れがなくなったりしてコードの保守性が上がる。

```java
Class Money{
 int amount;//金額
 Currency currency;//通過
 if（amount<0）{
 throw new IllegaryArgumenetException("金額には０以上を設定してください");)
 }
 if（currency==null）{
 throw new IllegaryArgumenetException("通過単位を指定してください");
 }
 Money(int amount,Currency currency){
  this.amount=amount;
  this.currency=currency;
  } 
  
  //金額加算ロジック
  void add(int amount){
  amout+=amount;
  }
}
```

データクラスとはAPIエンドポイントや定数などを定義しているクラスである。

## 補足　データクラスとDTOの違い
データクラスとDTOについて違いが自分の中で明確にわからなかったので整理する。

**データクラス**

- データを定義し、操作するもの


**DTO**

- データの転送に特化したものでロジックはバリデーション程度しか持たない

## インスタンス変数、メソッド、ローカル変数は不変にする

もしインスタンス変数をどこからでも変更できるとなると、現在のインスタンス変数にどのような値が入っているのかを常に気にしないといけないし、思わぬバグに繋がる。そこで、インスタンス変数は変更不可にすることで、思わぬ変更をさせない。

```java
Class Money{
 final　int amount;//金額
 final Currency currency;//通過
 if（amount<0）{
 throw new IllegaryArgumenetException("金額には０以上を設定してください");)
 }
 if（currency==null）{
 throw new IllegaryArgumenetException("通過単位を指定してください");
 }
 Money(int amount,Currency currency){
  this.amount=amount;
  this.currency=currency;
  } 
  //金額加算ロジック
  void add(int amount){
  amout+=amount;
  }
}
```

こうすることで、変数を宣言した時かコンストラクタで初期化するときしか、インスタンス変数を操作することはできなくなりコードの可読性が上がる。

```java
Currency yen =new Currency("yen")
Money yen= new Money(100,yen);
```

もし新たにインスタンス変数を変更したいときは新たなインスタンスを作成することで変更する。

```java
CUrrency dol =new CUrrency("dol")
Money dol= new Money(100,dol);
```
# 低凝集を防ぐ

## staticsメソッドの使いどころ

staticsメソッドの特徴としては以下である。

- クラスレベルで存在し、インスタンス化不要で呼び出せる
- インスタンス変数にアクセスできない
- this キーワードが使用できない
- クラスの全インスタンス間で共有される（static変数の場合）

staticsメソッドはインスタンス変数を使えないのでstaticsメソッドを使った段階でデータとデータの操作ロジックが乖離してしまい低凝集になってしまう。なのでstaticsメソッドの使い所について理解しておかなければいけない。

[static修飾子](https://java-code.jp/130)

### 定数やグローバル変数を定義する場合

```java
public class Constants {
    public static final double PI = 3.14159;
    public static final String APP_NAME = "MyApp";
    public static final int MAX_USERS = 100;
}

// 使用例
double circumference = 2 * Constants.PI * radius;
```

そのシステム全体で使用される定数(グローバル変数)は、一度定義するとそれをシステム全体で共有して欲しいので、クラスの全インスタンスで共有される、staticsメソッドを使用する。

### シングルトンパターンの実装

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

// 使用例
Singleton singleton = Singleton.getInstance();
```

シングルトンパターンはもシステム全体で１つのインスタンスが共有されることをさし、これを実現するためにstaticsが使用される。

### 横断的関心事の実装

横断的関心事とは以下のようなものである。以下引用。

> **コンポーネントとして正しく分離するのが難しい関心事や、複数のコンポーネントに跨る関心事は横断的な関心事と呼ばれています。**
> 
> - ロギング
> - トラッキング
> - 認可
> - 永続性
> - キャッシュ
> - デバッグ
> - トレース
> - 分散処理
> - 例外処理
> 
> 皆様も、ロギング処理を全てのクラスの全てのメソッドの先頭行に書いたり、データ取得APIのリクエスト前に認可APIを叩くといった処理をどの様に分離しようかと、頭を悩ませたことあるのではないのでしょうか？
> 
> また**人**というオブジェクトに対して**ロギング**というオブジェクトが依存してしまうと、現実世界に置き換えた際に違和感が生まれてしまいますし、本来の責務を超えて結合度が高まると思わぬ不具合を生みやすくなってしまいます。
> 

[アスペクト指向を利用した関心事の分離 - Qiita](https://qiita.com/katsutomu/items/473ced7a31ea3e459f42#アスペクト指向プログラミングaopとは何か)

このような横断的関心事に関してはシステム内で共通処理として実装して、それを複数のクラスから呼び出す。また、横断的関心ごとを共通クラスに実装する際には例えばロギングに関する処理とバリデーションに関する処理が同じ共通クラスに書かれると単一責任原則を守れなくなるので、以下のように横断的関心事ごとに実装した方がいい。

```java
// ロギング関連の横断的関心事
public class LoggingUtils {
    public static void info(String message) {
        System.out.println("[INFO] " + getCurrentTimestamp() + " - " + message);
    }

    public static void error(String message, Exception e) {
        System.err.println("[ERROR] " + getCurrentTimestamp() + " - " + message);
        e.printStackTrace();
    }

    private static String getCurrentTimestamp() {
        return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
    }
}

// バリデーション関連の横断的関心事
public class ValidationUtils {
    public static boolean isValidEmail(String email) {
        // メールアドレスのバリデーションロジック
        return email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }

    public static boolean isValidPhoneNumber(String phoneNumber) {
        // 電話番号のバリデーションロジック
        return phoneNumber.matches("^\\d{10}$");
    }
}

// セキュリティ関連の横断的関心事
public class SecurityUtils {
    public static String hashPassword(String password) {
        // パスワードハッシュ化ロジック
        return BCrypt.hashpw(password, BCrypt.gensalt());
    }

    public static boolean verifyPassword(String password, String hashedPassword) {
        // パスワード検証ロジック
        return BCrypt.checkpw(password, hashedPassword);
    }
}

// 日付操作関連の横断的関心事
public class DateUtils {
    public static String formatDate(Date date, String pattern) {
        return new SimpleDateFormat(pattern).format(date);
    }

    public static Date parseDate(String dateString, String pattern) throws ParseException {
        return new SimpleDateFormat(pattern).parse(dateString);
    }
}
```

こうすることで以下のような利点がある。

- 単一責任の原則に従う
- 凝集度の向上
- 再利用性の向上
- テスタビリティの向上


## プリミティブ型に執着しない

プリミティブ型とはintやStringなど標準で準備されている型のことである。

もし、お金を計算するクラスでそのクラスに渡す引数をintで定義するとintの不正値を取り除くために型ガードを実装する必要がある。ただし、もしMoneyクラスを定義してそれを引数とし渡せばそのクラスを利用する際に、利用者はこのような確認処理をする必要がない。つまりデータクラスを使用する際に使用者側で確認することが少なくなるので追加でバリデーションなどを実装する必要がなくなり、結果としてプリミティブ型を使用した方が高凝集になる。

利用する側のクラスはMoneyクラスを使うことでガード節をすることができない。








# コレクションの実装

コレクションを実装するときの注意点。

## 自前でコレクションを実装しない

javaであればStreamAPIを使用すればわざわざ複雑な処理を実装しなくて済むので言語ごとにすでに搭載されているAPIは使用する。

## ループ内のネストを減らす

ループ内でネスト構造があると可読性が下がるので以下の方法を使用してループ内のネストを減らす。

### 早期continue

```java
public class UserValidator {
    public void validateUsers(List<User> users) {
        for (User user : users) {
            // 無効なユーザーは早期にスキップ
            if (!isValidAge(user)) continue;
            if (!isValidEmail(user)) continue;
            if (!isValidUsername(user)) continue;

            // 全ての検証をパスしたユーザーの処理
            processValidUser(user);
        }
    }

    private boolean isValidAge(User user) {
        return user.getAge() >= 18;
    }

    private boolean isValidEmail(User user) {
        return user.getEmail().contains("@");
    }

    private boolean isValidUsername(User user) {
        return user.getUsername().length() >= 3;
    }

    private void processValidUser(User user) {
        System.out.println("処理中のユーザー: " + user.getUsername());
        // ユーザー処理ロジック
    }
```

ifの早期リターンと同様に、条件に一致しなかった場合にはcontinueでループを抜けることで可読性が上がる。breakも同様である。
### ファーストコレクションを使用して低凝集なコレクションを改善する

ファーストコレクションとは、よく出てくるようなコレクションの処理をクラスにまとめていろんなところに同じ処理が何回も描かれることを防ぐ手法である。これは以下の記事にも記載されているがリファクタ期などでやるべきで最初は同じような処理がたくさん出てくるかわからないので、ここまでしなくていいかなと思う。自社サービスなどでは運用していくのでこの観点は必要かもしれないがSIerでは実際に運用するということはそこまでないので実務でここまですることはないと思う。

[ファーストクラスコレクションの実装と、その使い方](https://zenn.dev/tesnshin_o255/articles/a9af0a9a2e5596)
