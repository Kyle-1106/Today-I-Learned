- [説明](#説明)
- [共通](#共通)
  - [単一責任原則を守る](#単一責任原則を守る)
  - [インスタンス変数、ローカル変数、メソッドなどは基本的に不変にする](#インスタンス変数ローカル変数メソッドなどは基本的に不変にする)
  - [staticsを使用する場合](#staticsを使用する場合)
  - [名前設計](#名前設計)
    - [目的駆動設計を心がける](#目的駆動設計を心がける)
    - [より具体的に意味範囲が狭い目的に特化した名前をつける](#より具体的に意味範囲が狭い目的に特化した名前をつける)
    - [存在ベースでなくて目的ベースで名前を考える](#存在ベースでなくて目的ベースで名前を考える)
    - [命名規則アンチパターン](#命名規則アンチパターン)
  - [条件分岐の実装](#条件分岐の実装)
  - [コレクションの実装](#コレクションの実装)
  - [疎結合にする](#疎結合にする)
    - [継承よりも委譲を使う](#継承よりも委譲を使う)
    - [DRY原則を使う時には注意](#dry原則を使う時には注意)
- [変数](#変数)
  - [マジックナンバーを使用しない](#マジックナンバーを使用しない)
  - [基本的にはprivate](#基本的にはprivate)
- [メソッド](#メソッド)
  - [共通](#共通-1)
    - [プリミティブ型(StringやIntgerなど)に固執しない](#プリミティブ型stringやintgerなどに固執しない)
    - [コマンドクエリ分離の法則](#コマンドクエリ分離の法則)
  - [引数](#引数)
  - [戻り値](#戻り値)
- [クラス](#クラス)
  - [基本方針](#基本方針)
  - [コンストラクタで必ず初期化する](#コンストラクタで必ず初期化する)
  - [ガード節を設定する](#ガード節を設定する)
  - [値オブジェクトを意識して、データと関連ロジックは同じクラスに記述する](#値オブジェクトを意識してデータと関連ロジックは同じクラスに記述する)
- [アプリケーション全体構成](#アプリケーション全体構成)
  - [技術駆動パッケージングを使用しない](#技術駆動パッケージングを使用しない)

# 説明
これはいいコードと悪いコードで学ぶ設計入門を読んで学んだことをまとめて、実際に自分が設計・コーディングする際に気をつけるべきことをリストアップしたものである。



# 共通

## 単一責任原則を守る

## インスタンス変数、ローカル変数、メソッドなどは基本的に不変にする

可変にすることで副作用が生じる危険性があったり、可読性が下がるので、基本的には不変にする。可変にしていいのは、ループ内やif内など、スコープが限定される時だけ。

## staticsを使用する場合

staticsは基本的には使用しないが使用していいのは以下のような場合である。

- 定数やグローバル変数を定義するとき
- シングルトンパターン実装時
- 横断的関心事の実装

## 名前設計

### 目的駆動設計を心がける

### より具体的に意味範囲が狭い目的に特化した名前をつける

例えば商品クラスではなく、

- 予約品
- 注文品
- 在庫品
- 発送品

などのクラスに分けて、商品という大きな概念をより具体的に意味範囲を狭くする。

### 存在ベースでなくて目的ベースで名前を考える

| 存在ベース | 目的ベース |
| --- | --- |
| 住所 | 配送元、配送先、勤務地 |
| 金額 | 請求金額、消費税額、延滞補償料 |
| ユーザ | アカウント、個人プロフィール |

### 命名規則アンチパターン

- 技術駆動名前設計
- 驚き最小の原則→名前からイメージできる実装と実際の実装の乖離を最小限にする
- データクラスで~infoとか~dataにしない
- 動詞+目的語のメソッドに注意→クラスAの中にクラスAに関係ないことが混ざり、単一責任原則を守らなくなる

## 条件分岐の実装

- 早期リターンを使用してネストを浅くする
- interfaceを使用して条件分岐をスマートにする

## コレクションの実装

- 自前のコレクションを実装せずに使えるものは使う
- ループ内のネストを浅くする

## 疎結合にする

### 継承よりも委譲を使う

継承では親クラスと密結合になるのでis-aの関係が成り立たない場合には委譲を使う

### DRY原則を使う時には注意

概念や文脈の異なるが、同じようなことをしている処理を無理にまとめない

# 変数

## マジックナンバーを使用しない

## 基本的にはprivate

publicを使用するのは以下のような場合

- グローバル変数
- アプリ全体で使用する設定
- 横断的関心事

# メソッド


## 共通

### プリミティブ型(StringやIntgerなど)に固執しない

プリミティブだとデータクラスのガード節が使用できないので、引数や戻り値にはできるだけデータクラスを使用する。

### コマンドクエリ分離の法則

状態変更（コマンド）と状態を返す（クエリ）を同じメソッド内でしない。

## 引数

- 不変にする
- フラグ引数を使わない
- nullを渡さない

## 戻り値

- 型を定義する
- nullを渡さない

# クラス

## 基本方針

クラス単体で正常に動作し、クラスの利用者がクラスの実装を気にせずに利用できる。

## コンストラクタで必ず初期化する

コンストラクタを実装しないとデフォルトコンストラクタが実装されることになるがデフォルトコンストラクタではガード節などを実装できないので、クラスとして不十分。

## ガード節を設定する

引数をクラスに渡すときは不正値を必ずガード節で取り除く。

## 値オブジェクトを意識して、データと関連ロジックは同じクラスに記述する

ただのデータクラスとそのデータを扱う計算クラスというように分離すると低凝集になるので同じクラスに実装する

# アプリケーション全体構成

## 技術駆動パッケージングを使用しない
