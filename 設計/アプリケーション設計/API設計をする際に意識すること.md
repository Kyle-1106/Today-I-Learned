
# 目的

APIを設計する際にはさまざまなことを考慮する必要があるのでそれらについて、何を考えるべきかについてまとめる。

# 目次
- [目的](#目的)
- [目次](#目次)
- [必要APIの洗い出し](#必要apiの洗い出し)
- [エンドポイント設計](#エンドポイント設計)
  - [根本的な考え方](#根本的な考え方)
    - [1スクリーン1API](#1スクリーン1api)
    - [URIにはapiの文字を入れる](#uriにはapiの文字を入れる)
  - [短くて入力しやすい](#短くて入力しやすい)
  - [APIのエンドポイントから何のAPIか理解できる](#apiのエンドポイントから何のapiか理解できる)
  - [サーバの内部構造はエンドポイントからは判断できないように](#サーバの内部構造はエンドポイントからは判断できないように)
  - [命名規則](#命名規則)
    - [複数形の名詞を使う](#複数形の名詞を使う)
    - [動詞は極力入れない](#動詞は極力入れない)
    - [利用する単語はよく使われているものにする](#利用する単語はよく使われているものにする)
    - [小文字を使う](#小文字を使う)
    - [-を使って単語を繋げる](#-を使って単語を繋げる)
- [レスポンス設計](#レスポンス設計)
  - [レスポンスの基礎構造](#レスポンスの基礎構造)
  - [ステータスライン](#ステータスライン)
  - [ヘッダー](#ヘッダー)
  - [ボディ](#ボディ)
    - [エンベロープは使わない](#エンベロープは使わない)
    - [不必要にネストしない](#不必要にネストしない)
    - [配列は配列として返すのかオブジェクトにするか](#配列は配列として返すのかオブジェクトにするか)
    - [レスポンスデータのフォーマット](#レスポンスデータのフォーマット)
    - [エラーレスポンス](#エラーレスポンス)
- [セキュリティ](#セキュリティ)
- [参考記事等](#参考記事等)




# 必要APIの洗い出し

まずは機能要件から必要となるAPIを洗い出す。

# エンドポイント設計

## 根本的な考え方

APIを実装する上でまず気にしないといけないのがエンドポイントである。エンドポイントを設計する際には

**覚えやすく、どんな機能を持つURIなのかが一目でわかる**

ように設計する必要がある。そのために考慮するべきことは以下である。

### 1スクリーン1API

１つのAPIには１つの機能を持たせることが基本だが、それよりも強固な考えとして「1スクリーン1API」があるので、ある画面に遷移した際に複数のAPIを呼ばないといけないような場合があればその時には1つのAPIに複数の機能を持たせつべきである。

### URIにはapiの文字を入れる

一般的には

```jsx
https://api.com/v1
```

のようにapiという文字をエンドポイントに入れる。

**覚えやすく、どんな機能を持つURIなのかが一目でわかる**

エンドポイントを設計するために意識することは以下である。

## 短くて入力しやすい

その通り

## APIのエンドポイントから何のAPIか理解できる

エンドポイントを見た時にそれが何をするためのAPIかわかるかどうかはとても重要である。

例

```jsx
https://api.com/v1/users
```

上のようなエンドポイントであればGETであればユーザ全取得、POSTであればユーザ新規登録であることが一発で理解できる。このように設計するべき。

## サーバの内部構造はエンドポイントからは判断できないように

ユーザからするとAPIの内部構造については関係ないし、要らぬ情報を出すとセキュリティリスクが高まるので内部情報は出さない

## 命名規則

エンドポイント設計の命名規則には以下のようなものある。

### 複数形の名詞を使う

根本的な考え方としてURIはリソースという考えがある。そのため、URIは集合であり、複数形で表されるべきである。以下のようなエンドポイントがいい。

```jsx
api.com/v1/users/:id
```

こうすればこれはGETであればusersというユーザ情報から特定のユーザの情報を取得すること、POSTやPUTであれば更新を意味していることが一発でわかる。

### 動詞は極力入れない

そもそも動詞に関してはHTTPメソッドでGETやPOSTを指定しているのでわざわざgetUserなどといったエンドポイントにする必要はないし、動詞が重複していて気持ち悪い。ただ検索などはsearchという単語を使用した方がわかりやすく、そこは時と場合による。

### 利用する単語はよく使われているものにする

[プログラミングでよく使う英単語のまとめ【随時更新】 - Qiita](https://qiita.com/Ted-HM/items/7dde25dcffae4cdc7923)

取得はfindでなく、searchなど一般的に同じような意味だが使われていない単語もあるので上の記事など参考にする。

### 小文字を使う

### -を使って単語を繋げる

そもそもできる限りは単語をつなげるような名前設計にはしたくないが仕方ない時には-で繋げる

　

# レスポンス設計

## レスポンスの基礎構造

レスポンスは

- ステータスライン
- ヘッダー
- ボディ

で構成されている。

これらについて見ていく。

## ステータスライン

HTTPのステータスコードがとHTTPメソッドが記載されている。

[HTTPステータスコード 完全に理解した - Qiita](https://qiita.com/unsoluble_sugar/items/b080a16701946fcfce70)

実際の感じ・

```json
GET /index.html HTTP/1.1 
```

## ヘッダー

ヘッダーには以下のような情報を格納する。

```json
クライアントの情報
User-Agent - クライアントのソフトウェア名やバージョン
Accept-Language - クライアントの使用言語設定
リクエストのメタデータ
Content-Type - リクエストボディのデータ形式
Content-Length - リクエストボディの長さ
認証/認可情報
Authorization - 認証トークンやAPIキー等
Cookie - セッション管理に使用するCookie
APIの指定
Accept - 受け入れ可能なレスポンスのデータ形式
API-Version - 使用したいAPIのバージョン
その他
Cache-Control - キャッシュ指示
If-Modified-Since - 最終更新日時の指定
```

[APIリクエストヘッダーとは、その書き方を解説！](https://apidog.com/jp/blog/introduction-to-api-request-header/)

実際には以下のようになっている。

```json
Host: localhost:8080
Connection: keep-alive
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) //クライアントのソフトウェア名やバージョン
Accept: */* //受け入れ可能なレスポンスのデータ形式
Referer: http://localhost:8080/
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: ja,en-US;q=0.8,en;q=0.6　//クライアントの使用言語設定
Cookie: user_id=12345678 //セッション管理に使用するCookie

```

## ボディ

### エンベロープは使わない

```json
{
 "header":{
  "satus":"success",
  "errorcode":0,
 }
 "response":{
 ----------
 }
}
```

たまにボデイの中にheaderとしてステータスコードを入れてるようなAPIがあるが、これらの情報はボディではなく、ヘッダーに入れるべきなのでエンべロープは使わないように。

### 不必要にネストしない

ネスト構造にした方が構造がわかりやすい時のみネストにする。

### 配列は配列として返すのかオブジェクトにするか

配列をレスポンスとして返す場合には以下のような選択肢がある。

配列そのまま返すパターン

```json
//配列をそのまま返す
[
 　{ 
  "id":1,
  "name":"john"
 },
  　{ 
  "id":2,
  "name":"mary"
 }
]
```

オブジェクトとして返すパターン

```json
//オブジェクトとして返す
{
 "friends": [
  { 
   "id":1,
   "name":"john"
  },
  { 
  "id":2,
  "name":"mary"
  },
 ]
}
```

この２つのパターンがあるが、よりベターなのはオブジェクトとして返す方法である。理由は以下である。

- レスポンスデータが何を返しているかわかりやすい
- レスポンスデータをオブジェクトとして統一できる
- セキュリティリスクを回避できる

最初の２つはその通りである。最後に関しては、JSONインジェクションという攻撃に対して強くなる。JSONインジェクションとは、JSONを読み込むことで、ブラウザに他のサービスのAPIが提供するAPIが提供するJSONを読み込ませることで内容を不正に取得する方法である。これはオブジェクトとして実装することで回避できる。

### レスポンスデータのフォーマット

**プロパティの命名**

プロパティの命名はキャメルケース(userId)を使用する。

**性別のデータ**

性別は0と1で表す方法とmaleとfemaleで表す方法があるが、後者の方が一般的

**日付データ**

日付を返す際のフォーマットは色々あるが基本的にはRFC 3330を使用するべきである。

```bash
RFC 3339
2015-10-21T11:30:22+09:00
```

[RFC 9557: RFC 3339 拡張日付時刻形式 Internet Extended Date/Time Format (IXDTF)](https://zenn.dev/pixiv/articles/23b726da2236cd)

**大きな整数を扱う際には文字列として扱う**

桁数が大きすぎるとオーバフローを起こして誤差が出ることがあるので、BIGINTやLONGなどの64ビットの整数型などは文字列として扱う。

```json
{
  "id": 26603129394698048,
  "id_str": "26603129394698048"
  ...
}
```

### エラーレスポンス

エラーを返す際には以下のことに気を付ける。

**エラーの詳細はレスポンスボディに入れる**

```json

{
  "error": {
    "code": 400,
    "message": "Invalid request"
  }
}
```

このようにボディにエラー詳細を入れることでAPI利用者は実装しやすくなる。

**エラー時にHTMLが返されることを防ぐ**

404や500の際にWebサーバのデフォルトエラーページが返されないように抜け漏れなく実装するのと、設定の見直しを忘れない。

# セキュリティ

代表的な攻撃手法とその対策についてまとめる。

ここは多いので後で記述。

IPAにまとまっている。

# 参考記事等

[Web API 設計入門](https://zenn.dev/nakaryo/articles/87b15866d67efe#エラーの設計)
[Web API: The Good Parts](https://www.oreilly.co.jp/books/9784873116860/)